// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: plugin.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Proto file for Pact plugin interface V1

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request to verify the plugin has loaded OK
public struct Io_Pact_Plugin_InitPluginRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Implementation calling the plugin
  public var implementation: String = String()

  /// Version of the implementation
  public var version: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Entry to be added to the core catalogue. Each entry describes one of the features the plugin provides.
/// Entries will be stored in the catalogue under the key "plugin/$name/$type/$key".
public struct Io_Pact_Plugin_CatalogueEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Entry type
  public var type: Io_Pact_Plugin_CatalogueEntry.EntryType = .contentMatcher

  /// Entry key
  public var key: String = String()

  /// Associated data required for the entry. For CONTENT_MATCHER and CONTENT_GENERATOR types, a "content-types"
  /// value (separated by semi-colons) is required for all the content types the plugin supports.
  public var values: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum EntryType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Matcher for contents of messages, requests or response bodies
    case contentMatcher // = 0

    /// Generator for contents of messages, requests or response bodies
    case contentGenerator // = 1

    /// Transport for a network protocol
    case transport // = 2

    /// Matching rule for content field/values
    case matcher // = 3

    /// Type of interaction
    case interaction // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .contentMatcher
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .contentMatcher
      case 1: self = .contentGenerator
      case 2: self = .transport
      case 3: self = .matcher
      case 4: self = .interaction
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .contentMatcher: return 0
      case .contentGenerator: return 1
      case .transport: return 2
      case .matcher: return 3
      case .interaction: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Io_Pact_Plugin_CatalogueEntry.EntryType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Io_Pact_Plugin_CatalogueEntry.EntryType] = [
    .contentMatcher,
    .contentGenerator,
    .transport,
    .matcher,
    .interaction,
  ]
}

#endif  // swift(>=4.2)

/// Response to init plugin, providing the catalogue entries the plugin provides
public struct Io_Pact_Plugin_InitPluginResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of entries the plugin supports
  public var catalogue: [Io_Pact_Plugin_CatalogueEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Catalogue of Core Pact + Plugin features
public struct Io_Pact_Plugin_Catalogue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of entries from the core catalogue
  public var catalogue: [Io_Pact_Plugin_CatalogueEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message representing a request, response or message body
public struct Io_Pact_Plugin_Body {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The content type of the body in MIME format (i.e. application/json)
  public var contentType: String = String()

  /// Bytes of the actual content
  public var content: SwiftProtobuf.Google_Protobuf_BytesValue {
    get {return _content ?? SwiftProtobuf.Google_Protobuf_BytesValue()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  public var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  public mutating func clearContent() {self._content = nil}

  /// Content type override to apply (if required). If omitted, the default rules of the Pact implementation
  /// will be used
  public var contentTypeHint: Io_Pact_Plugin_Body.ContentTypeHint = .default

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Enum of content type override. This is a hint on how the content type should be treated.
  public enum ContentTypeHint: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Determine the form of the content using the default rules of the Pact implementation
    case `default` // = 0

    /// Contents must always be treated as a text form
    case text // = 1

    /// Contents must always be treated as a binary form
    case binary // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .default
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .text
      case 2: self = .binary
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .default: return 0
      case .text: return 1
      case .binary: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _content: SwiftProtobuf.Google_Protobuf_BytesValue? = nil
}

#if swift(>=4.2)

extension Io_Pact_Plugin_Body.ContentTypeHint: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Io_Pact_Plugin_Body.ContentTypeHint] = [
    .default,
    .text,
    .binary,
  ]
}

#endif  // swift(>=4.2)

/// Request to preform a comparison on an actual body given the expected one
public struct Io_Pact_Plugin_CompareContentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Expected body from the Pact interaction
  public var expected: Io_Pact_Plugin_Body {
    get {return _expected ?? Io_Pact_Plugin_Body()}
    set {_expected = newValue}
  }
  /// Returns true if `expected` has been explicitly set.
  public var hasExpected: Bool {return self._expected != nil}
  /// Clears the value of `expected`. Subsequent reads from it will return its default value.
  public mutating func clearExpected() {self._expected = nil}

  /// Actual received body
  public var actual: Io_Pact_Plugin_Body {
    get {return _actual ?? Io_Pact_Plugin_Body()}
    set {_actual = newValue}
  }
  /// Returns true if `actual` has been explicitly set.
  public var hasActual: Bool {return self._actual != nil}
  /// Clears the value of `actual`. Subsequent reads from it will return its default value.
  public mutating func clearActual() {self._actual = nil}

  /// If unexpected keys or attributes should be allowed. Setting this to false results in additional keys or fields
  /// will cause a mismatch
  public var allowUnexpectedKeys: Bool = false

  /// Map of expressions to matching rules. The expressions follow the documented Pact matching rule expressions
  public var rules: Dictionary<String,Io_Pact_Plugin_MatchingRules> = [:]

  /// Additional data added to the Pact/Interaction by the plugin
  public var pluginConfiguration: Io_Pact_Plugin_PluginConfiguration {
    get {return _pluginConfiguration ?? Io_Pact_Plugin_PluginConfiguration()}
    set {_pluginConfiguration = newValue}
  }
  /// Returns true if `pluginConfiguration` has been explicitly set.
  public var hasPluginConfiguration: Bool {return self._pluginConfiguration != nil}
  /// Clears the value of `pluginConfiguration`. Subsequent reads from it will return its default value.
  public mutating func clearPluginConfiguration() {self._pluginConfiguration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expected: Io_Pact_Plugin_Body? = nil
  fileprivate var _actual: Io_Pact_Plugin_Body? = nil
  fileprivate var _pluginConfiguration: Io_Pact_Plugin_PluginConfiguration? = nil
}

/// Indicates that there was a mismatch with the content type
public struct Io_Pact_Plugin_ContentTypeMismatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Expected content type (MIME format)
  public var expected: String = String()

  /// Actual content type received (MIME format)
  public var actual: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A mismatch for an particular item of content
public struct Io_Pact_Plugin_ContentMismatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Expected data bytes
  public var expected: SwiftProtobuf.Google_Protobuf_BytesValue {
    get {return _expected ?? SwiftProtobuf.Google_Protobuf_BytesValue()}
    set {_expected = newValue}
  }
  /// Returns true if `expected` has been explicitly set.
  public var hasExpected: Bool {return self._expected != nil}
  /// Clears the value of `expected`. Subsequent reads from it will return its default value.
  public mutating func clearExpected() {self._expected = nil}

  /// Actual data bytes
  public var actual: SwiftProtobuf.Google_Protobuf_BytesValue {
    get {return _actual ?? SwiftProtobuf.Google_Protobuf_BytesValue()}
    set {_actual = newValue}
  }
  /// Returns true if `actual` has been explicitly set.
  public var hasActual: Bool {return self._actual != nil}
  /// Clears the value of `actual`. Subsequent reads from it will return its default value.
  public mutating func clearActual() {self._actual = nil}

  /// Description of the mismatch
  public var mismatch: String = String()

  /// Path to the item that was matched. This is the value as per the documented Pact matching rule expressions.
  public var path: String = String()

  /// Optional diff of the contents
  public var diff: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expected: SwiftProtobuf.Google_Protobuf_BytesValue? = nil
  fileprivate var _actual: SwiftProtobuf.Google_Protobuf_BytesValue? = nil
}

/// List of content mismatches
public struct Io_Pact_Plugin_ContentMismatches {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mismatches: [Io_Pact_Plugin_ContentMismatch] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response to the CompareContentsRequest with the results of the comparison
public struct Io_Pact_Plugin_CompareContentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Error message if an error occurred. If this field is set, the remaining fields will be ignored and the
  /// verification marked as failed
  public var error: String = String()

  /// There was a mismatch with the types of content. If this is set, the results may not be set.
  public var typeMismatch: Io_Pact_Plugin_ContentTypeMismatch {
    get {return _typeMismatch ?? Io_Pact_Plugin_ContentTypeMismatch()}
    set {_typeMismatch = newValue}
  }
  /// Returns true if `typeMismatch` has been explicitly set.
  public var hasTypeMismatch: Bool {return self._typeMismatch != nil}
  /// Clears the value of `typeMismatch`. Subsequent reads from it will return its default value.
  public mutating func clearTypeMismatch() {self._typeMismatch = nil}

  /// Results of the match, keyed by matching rule expression
  public var results: Dictionary<String,Io_Pact_Plugin_ContentMismatches> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _typeMismatch: Io_Pact_Plugin_ContentTypeMismatch? = nil
}

/// Request to configure/setup an interaction so that it can be verified later
public struct Io_Pact_Plugin_ConfigureInteractionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Content type of the interaction (MIME format)
  public var contentType: String = String()

  /// This is data specified by the user in the consumer test
  public var contentsConfig: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _contentsConfig ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_contentsConfig = newValue}
  }
  /// Returns true if `contentsConfig` has been explicitly set.
  public var hasContentsConfig: Bool {return self._contentsConfig != nil}
  /// Clears the value of `contentsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearContentsConfig() {self._contentsConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _contentsConfig: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// Represents a matching rule
public struct Io_Pact_Plugin_MatchingRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of the matching rule
  public var type: String = String()

  /// Associated data for the matching rule
  public var values: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _values ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_values = newValue}
  }
  /// Returns true if `values` has been explicitly set.
  public var hasValues: Bool {return self._values != nil}
  /// Clears the value of `values`. Subsequent reads from it will return its default value.
  public mutating func clearValues() {self._values = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _values: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// List of matching rules
public struct Io_Pact_Plugin_MatchingRules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rule: [Io_Pact_Plugin_MatchingRule] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Example generator
public struct Io_Pact_Plugin_Generator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of generator
  public var type: String = String()

  /// Associated data for the generator
  public var values: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _values ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_values = newValue}
  }
  /// Returns true if `values` has been explicitly set.
  public var hasValues: Bool {return self._values != nil}
  /// Clears the value of `values`. Subsequent reads from it will return its default value.
  public mutating func clearValues() {self._values = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _values: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// Plugin configuration added to the pact file by the ConfigureInteraction step
public struct Io_Pact_Plugin_PluginConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Data to be persisted against the interaction
  public var interactionConfiguration: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _interactionConfiguration ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_interactionConfiguration = newValue}
  }
  /// Returns true if `interactionConfiguration` has been explicitly set.
  public var hasInteractionConfiguration: Bool {return self._interactionConfiguration != nil}
  /// Clears the value of `interactionConfiguration`. Subsequent reads from it will return its default value.
  public mutating func clearInteractionConfiguration() {self._interactionConfiguration = nil}

  /// Data to be persisted in the Pact file metadata (Global data)
  public var pactConfiguration: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _pactConfiguration ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_pactConfiguration = newValue}
  }
  /// Returns true if `pactConfiguration` has been explicitly set.
  public var hasPactConfiguration: Bool {return self._pactConfiguration != nil}
  /// Clears the value of `pactConfiguration`. Subsequent reads from it will return its default value.
  public mutating func clearPactConfiguration() {self._pactConfiguration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _interactionConfiguration: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _pactConfiguration: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// Response to the configure/setup an interaction request
public struct Io_Pact_Plugin_InteractionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contents for the interaction
  public var contents: Io_Pact_Plugin_Body {
    get {return _contents ?? Io_Pact_Plugin_Body()}
    set {_contents = newValue}
  }
  /// Returns true if `contents` has been explicitly set.
  public var hasContents: Bool {return self._contents != nil}
  /// Clears the value of `contents`. Subsequent reads from it will return its default value.
  public mutating func clearContents() {self._contents = nil}

  /// All matching rules to apply
  public var rules: Dictionary<String,Io_Pact_Plugin_MatchingRules> = [:]

  /// Generators to apply
  public var generators: Dictionary<String,Io_Pact_Plugin_Generator> = [:]

  /// For message interactions, any metadata to be applied
  public var messageMetadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _messageMetadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_messageMetadata = newValue}
  }
  /// Returns true if `messageMetadata` has been explicitly set.
  public var hasMessageMetadata: Bool {return self._messageMetadata != nil}
  /// Clears the value of `messageMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearMessageMetadata() {self._messageMetadata = nil}

  /// Plugin specific data to be persisted in the pact file
  public var pluginConfiguration: Io_Pact_Plugin_PluginConfiguration {
    get {return _pluginConfiguration ?? Io_Pact_Plugin_PluginConfiguration()}
    set {_pluginConfiguration = newValue}
  }
  /// Returns true if `pluginConfiguration` has been explicitly set.
  public var hasPluginConfiguration: Bool {return self._pluginConfiguration != nil}
  /// Clears the value of `pluginConfiguration`. Subsequent reads from it will return its default value.
  public mutating func clearPluginConfiguration() {self._pluginConfiguration = nil}

  /// Markdown/HTML formatted text representation of the interaction
  public var interactionMarkup: String = String()

  public var interactionMarkupType: Io_Pact_Plugin_InteractionResponse.MarkupType = .commonMark

  /// Description of what part this interaction belongs to (in the case of there being more than one, for instance,
  /// request/response messages)
  public var partName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Type of markup used
  public enum MarkupType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// CommonMark format
    case commonMark // = 0

    /// HTML format
    case html // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .commonMark
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .commonMark
      case 1: self = .html
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .commonMark: return 0
      case .html: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _contents: Io_Pact_Plugin_Body? = nil
  fileprivate var _messageMetadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _pluginConfiguration: Io_Pact_Plugin_PluginConfiguration? = nil
}

#if swift(>=4.2)

extension Io_Pact_Plugin_InteractionResponse.MarkupType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Io_Pact_Plugin_InteractionResponse.MarkupType] = [
    .commonMark,
    .html,
  ]
}

#endif  // swift(>=4.2)

/// Response to the configure/setup an interaction request
public struct Io_Pact_Plugin_ConfigureInteractionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If an error occurred. In this case, the other fields will be ignored/not set
  public var error: String = String()

  /// The actual response if no error occurred.
  public var interaction: [Io_Pact_Plugin_InteractionResponse] = []

  /// Plugin specific data to be persisted in the pact file
  public var pluginConfiguration: Io_Pact_Plugin_PluginConfiguration {
    get {return _pluginConfiguration ?? Io_Pact_Plugin_PluginConfiguration()}
    set {_pluginConfiguration = newValue}
  }
  /// Returns true if `pluginConfiguration` has been explicitly set.
  public var hasPluginConfiguration: Bool {return self._pluginConfiguration != nil}
  /// Clears the value of `pluginConfiguration`. Subsequent reads from it will return its default value.
  public mutating func clearPluginConfiguration() {self._pluginConfiguration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pluginConfiguration: Io_Pact_Plugin_PluginConfiguration? = nil
}

/// Request to generate the contents using any defined generators
public struct Io_Pact_Plugin_GenerateContentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Original contents
  public var contents: Io_Pact_Plugin_Body {
    get {return _contents ?? Io_Pact_Plugin_Body()}
    set {_contents = newValue}
  }
  /// Returns true if `contents` has been explicitly set.
  public var hasContents: Bool {return self._contents != nil}
  /// Clears the value of `contents`. Subsequent reads from it will return its default value.
  public mutating func clearContents() {self._contents = nil}

  /// Generators to apply
  public var generators: Dictionary<String,Io_Pact_Plugin_Generator> = [:]

  /// Additional data added to the Pact/Interaction by the plugin
  public var pluginConfiguration: Io_Pact_Plugin_PluginConfiguration {
    get {return _pluginConfiguration ?? Io_Pact_Plugin_PluginConfiguration()}
    set {_pluginConfiguration = newValue}
  }
  /// Returns true if `pluginConfiguration` has been explicitly set.
  public var hasPluginConfiguration: Bool {return self._pluginConfiguration != nil}
  /// Clears the value of `pluginConfiguration`. Subsequent reads from it will return its default value.
  public mutating func clearPluginConfiguration() {self._pluginConfiguration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _contents: Io_Pact_Plugin_Body? = nil
  fileprivate var _pluginConfiguration: Io_Pact_Plugin_PluginConfiguration? = nil
}

/// Generated body/message response
public struct Io_Pact_Plugin_GenerateContentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var contents: Io_Pact_Plugin_Body {
    get {return _contents ?? Io_Pact_Plugin_Body()}
    set {_contents = newValue}
  }
  /// Returns true if `contents` has been explicitly set.
  public var hasContents: Bool {return self._contents != nil}
  /// Clears the value of `contents`. Subsequent reads from it will return its default value.
  public mutating func clearContents() {self._contents = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _contents: Io_Pact_Plugin_Body? = nil
}

/// Request to start a mock server
public struct Io_Pact_Plugin_StartMockServerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Interface to bind to. Will default to the loopback adapter
  public var hostInterface: String = String()

  /// Port to bind to. Default (or a value of 0) get the OS to open a random port
  public var port: UInt32 = 0

  /// If TLS should be used (if supported by the mock server)
  public var tls: Bool = false

  /// Pact as JSON to use for the mock server behaviour
  public var pact: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response to the start mock server request
public struct Io_Pact_Plugin_StartMockServerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var response: Io_Pact_Plugin_StartMockServerResponse.OneOf_Response? = nil

  /// If an error occurred
  public var error: String {
    get {
      if case .error(let v)? = response {return v}
      return String()
    }
    set {response = .error(newValue)}
  }

  /// Mock server details
  public var details: Io_Pact_Plugin_MockServerDetails {
    get {
      if case .details(let v)? = response {return v}
      return Io_Pact_Plugin_MockServerDetails()
    }
    set {response = .details(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable {
    /// If an error occurred
    case error(String)
    /// Mock server details
    case details(Io_Pact_Plugin_MockServerDetails)

  #if !swift(>=4.1)
    public static func ==(lhs: Io_Pact_Plugin_StartMockServerResponse.OneOf_Response, rhs: Io_Pact_Plugin_StartMockServerResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.details, .details): return {
        guard case .details(let l) = lhs, case .details(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Details on a running mock server
public struct Io_Pact_Plugin_MockServerDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Mock server unique ID
  public var key: String = String()

  /// Port the mock server is running on
  public var port: UInt32 = 0

  /// IP address the mock server is bound to. Probably an IP6 address, but may be IP4
  public var address: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to shut down a running mock server
/// TODO: replace this with MockServerRequest in the next major version
public struct Io_Pact_Plugin_ShutdownMockServerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The server ID to shutdown
  public var serverKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for a running mock server by ID
public struct Io_Pact_Plugin_MockServerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The server ID to shutdown
  public var serverKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Result of a request that the mock server received
public struct Io_Pact_Plugin_MockServerResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// service + method that was requested
  public var path: String = String()

  /// If an error occurred trying to handle the request
  public var error: String = String()

  /// Any mismatches that occurred
  public var mismatches: [Io_Pact_Plugin_ContentMismatch] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response to the shut down mock server request
/// TODO: replace this with MockServerResults in the next major version
public struct Io_Pact_Plugin_ShutdownMockServerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If the mock status is all ok
  public var ok: Bool = false

  /// The results of the test run, will contain an entry for each request received by the mock server
  public var results: [Io_Pact_Plugin_MockServerResult] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Matching results of the mock server.
public struct Io_Pact_Plugin_MockServerResults {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If the mock status is all ok
  public var ok: Bool = false

  /// The results of the test run, will contain an entry for each request received by the mock server
  public var results: [Io_Pact_Plugin_MockServerResult] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to prepare an interaction for verification
public struct Io_Pact_Plugin_VerificationPreparationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Pact as JSON to use for the verification
  public var pact: String = String()

  /// Interaction key for the interaction from the Pact that is being verified
  public var interactionKey: String = String()

  /// Any data supplied by the user to verify the interaction
  public var config: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _config ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {self._config = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _config: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// Request metadata value. Will either be a JSON-like value, or binary data
public struct Io_Pact_Plugin_MetadataValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Io_Pact_Plugin_MetadataValue.OneOf_Value? = nil

  public var nonBinaryValue: SwiftProtobuf.Google_Protobuf_Value {
    get {
      if case .nonBinaryValue(let v)? = value {return v}
      return SwiftProtobuf.Google_Protobuf_Value()
    }
    set {value = .nonBinaryValue(newValue)}
  }

  public var binaryValue: Data {
    get {
      if case .binaryValue(let v)? = value {return v}
      return Data()
    }
    set {value = .binaryValue(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    case nonBinaryValue(SwiftProtobuf.Google_Protobuf_Value)
    case binaryValue(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Io_Pact_Plugin_MetadataValue.OneOf_Value, rhs: Io_Pact_Plugin_MetadataValue.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.nonBinaryValue, .nonBinaryValue): return {
        guard case .nonBinaryValue(let l) = lhs, case .nonBinaryValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.binaryValue, .binaryValue): return {
        guard case .binaryValue(let l) = lhs, case .binaryValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Interaction request data to be sent or received for verification
public struct Io_Pact_Plugin_InteractionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request/Response body as bytes
  public var body: Io_Pact_Plugin_Body {
    get {return _body ?? Io_Pact_Plugin_Body()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  public var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  public mutating func clearBody() {self._body = nil}

  /// Metadata associated with the request/response
  public var metadata: Dictionary<String,Io_Pact_Plugin_MetadataValue> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _body: Io_Pact_Plugin_Body? = nil
}

/// Response for the prepare an interaction for verification request
public struct Io_Pact_Plugin_VerificationPreparationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var response: Io_Pact_Plugin_VerificationPreparationResponse.OneOf_Response? = nil

  /// If an error occurred
  public var error: String {
    get {
      if case .error(let v)? = response {return v}
      return String()
    }
    set {response = .error(newValue)}
  }

  /// Interaction data required to construct any request
  public var interactionData: Io_Pact_Plugin_InteractionData {
    get {
      if case .interactionData(let v)? = response {return v}
      return Io_Pact_Plugin_InteractionData()
    }
    set {response = .interactionData(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable {
    /// If an error occurred
    case error(String)
    /// Interaction data required to construct any request
    case interactionData(Io_Pact_Plugin_InteractionData)

  #if !swift(>=4.1)
    public static func ==(lhs: Io_Pact_Plugin_VerificationPreparationResponse.OneOf_Response, rhs: Io_Pact_Plugin_VerificationPreparationResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.interactionData, .interactionData): return {
        guard case .interactionData(let l) = lhs, case .interactionData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Request data to verify an interaction
public struct Io_Pact_Plugin_VerifyInteractionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Interaction data required to construct the request
  public var interactionData: Io_Pact_Plugin_InteractionData {
    get {return _interactionData ?? Io_Pact_Plugin_InteractionData()}
    set {_interactionData = newValue}
  }
  /// Returns true if `interactionData` has been explicitly set.
  public var hasInteractionData: Bool {return self._interactionData != nil}
  /// Clears the value of `interactionData`. Subsequent reads from it will return its default value.
  public mutating func clearInteractionData() {self._interactionData = nil}

  /// Any data supplied by the user to verify the interaction
  public var config: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _config ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {self._config = nil}

  /// Pact as JSON to use for the verification
  public var pact: String = String()

  /// Interaction key for the interaction from the Pact that is being verified
  public var interactionKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _interactionData: Io_Pact_Plugin_InteractionData? = nil
  fileprivate var _config: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Io_Pact_Plugin_VerificationResultItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Io_Pact_Plugin_VerificationResultItem.OneOf_Result? = nil

  public var error: String {
    get {
      if case .error(let v)? = result {return v}
      return String()
    }
    set {result = .error(newValue)}
  }

  public var mismatch: Io_Pact_Plugin_ContentMismatch {
    get {
      if case .mismatch(let v)? = result {return v}
      return Io_Pact_Plugin_ContentMismatch()
    }
    set {result = .mismatch(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable {
    case error(String)
    case mismatch(Io_Pact_Plugin_ContentMismatch)

  #if !swift(>=4.1)
    public static func ==(lhs: Io_Pact_Plugin_VerificationResultItem.OneOf_Result, rhs: Io_Pact_Plugin_VerificationResultItem.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mismatch, .mismatch): return {
        guard case .mismatch(let l) = lhs, case .mismatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Result of running the verification
public struct Io_Pact_Plugin_VerificationResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Was the verification successful?
  public var success: Bool = false

  /// Interaction data retrieved from the provider (optional)
  public var responseData: Io_Pact_Plugin_InteractionData {
    get {return _responseData ?? Io_Pact_Plugin_InteractionData()}
    set {_responseData = newValue}
  }
  /// Returns true if `responseData` has been explicitly set.
  public var hasResponseData: Bool {return self._responseData != nil}
  /// Clears the value of `responseData`. Subsequent reads from it will return its default value.
  public mutating func clearResponseData() {self._responseData = nil}

  /// Any mismatches that occurred
  public var mismatches: [Io_Pact_Plugin_VerificationResultItem] = []

  /// Output for the verification to display to the user
  public var output: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _responseData: Io_Pact_Plugin_InteractionData? = nil
}

/// Result of running the verification
public struct Io_Pact_Plugin_VerifyInteractionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var response: Io_Pact_Plugin_VerifyInteractionResponse.OneOf_Response? = nil

  /// If an error occurred trying to run the verification
  public var error: String {
    get {
      if case .error(let v)? = response {return v}
      return String()
    }
    set {response = .error(newValue)}
  }

  public var result: Io_Pact_Plugin_VerificationResult {
    get {
      if case .result(let v)? = response {return v}
      return Io_Pact_Plugin_VerificationResult()
    }
    set {response = .result(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable {
    /// If an error occurred trying to run the verification
    case error(String)
    case result(Io_Pact_Plugin_VerificationResult)

  #if !swift(>=4.1)
    public static func ==(lhs: Io_Pact_Plugin_VerifyInteractionResponse.OneOf_Response, rhs: Io_Pact_Plugin_VerifyInteractionResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.result, .result): return {
        guard case .result(let l) = lhs, case .result(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Io_Pact_Plugin_InitPluginRequest: @unchecked Sendable {}
extension Io_Pact_Plugin_CatalogueEntry: @unchecked Sendable {}
extension Io_Pact_Plugin_CatalogueEntry.EntryType: @unchecked Sendable {}
extension Io_Pact_Plugin_InitPluginResponse: @unchecked Sendable {}
extension Io_Pact_Plugin_Catalogue: @unchecked Sendable {}
extension Io_Pact_Plugin_Body: @unchecked Sendable {}
extension Io_Pact_Plugin_Body.ContentTypeHint: @unchecked Sendable {}
extension Io_Pact_Plugin_CompareContentsRequest: @unchecked Sendable {}
extension Io_Pact_Plugin_ContentTypeMismatch: @unchecked Sendable {}
extension Io_Pact_Plugin_ContentMismatch: @unchecked Sendable {}
extension Io_Pact_Plugin_ContentMismatches: @unchecked Sendable {}
extension Io_Pact_Plugin_CompareContentsResponse: @unchecked Sendable {}
extension Io_Pact_Plugin_ConfigureInteractionRequest: @unchecked Sendable {}
extension Io_Pact_Plugin_MatchingRule: @unchecked Sendable {}
extension Io_Pact_Plugin_MatchingRules: @unchecked Sendable {}
extension Io_Pact_Plugin_Generator: @unchecked Sendable {}
extension Io_Pact_Plugin_PluginConfiguration: @unchecked Sendable {}
extension Io_Pact_Plugin_InteractionResponse: @unchecked Sendable {}
extension Io_Pact_Plugin_InteractionResponse.MarkupType: @unchecked Sendable {}
extension Io_Pact_Plugin_ConfigureInteractionResponse: @unchecked Sendable {}
extension Io_Pact_Plugin_GenerateContentRequest: @unchecked Sendable {}
extension Io_Pact_Plugin_GenerateContentResponse: @unchecked Sendable {}
extension Io_Pact_Plugin_StartMockServerRequest: @unchecked Sendable {}
extension Io_Pact_Plugin_StartMockServerResponse: @unchecked Sendable {}
extension Io_Pact_Plugin_StartMockServerResponse.OneOf_Response: @unchecked Sendable {}
extension Io_Pact_Plugin_MockServerDetails: @unchecked Sendable {}
extension Io_Pact_Plugin_ShutdownMockServerRequest: @unchecked Sendable {}
extension Io_Pact_Plugin_MockServerRequest: @unchecked Sendable {}
extension Io_Pact_Plugin_MockServerResult: @unchecked Sendable {}
extension Io_Pact_Plugin_ShutdownMockServerResponse: @unchecked Sendable {}
extension Io_Pact_Plugin_MockServerResults: @unchecked Sendable {}
extension Io_Pact_Plugin_VerificationPreparationRequest: @unchecked Sendable {}
extension Io_Pact_Plugin_MetadataValue: @unchecked Sendable {}
extension Io_Pact_Plugin_MetadataValue.OneOf_Value: @unchecked Sendable {}
extension Io_Pact_Plugin_InteractionData: @unchecked Sendable {}
extension Io_Pact_Plugin_VerificationPreparationResponse: @unchecked Sendable {}
extension Io_Pact_Plugin_VerificationPreparationResponse.OneOf_Response: @unchecked Sendable {}
extension Io_Pact_Plugin_VerifyInteractionRequest: @unchecked Sendable {}
extension Io_Pact_Plugin_VerificationResultItem: @unchecked Sendable {}
extension Io_Pact_Plugin_VerificationResultItem.OneOf_Result: @unchecked Sendable {}
extension Io_Pact_Plugin_VerificationResult: @unchecked Sendable {}
extension Io_Pact_Plugin_VerifyInteractionResponse: @unchecked Sendable {}
extension Io_Pact_Plugin_VerifyInteractionResponse.OneOf_Response: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "io.pact.plugin"

extension Io_Pact_Plugin_InitPluginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitPluginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "implementation"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.implementation) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.implementation.isEmpty {
      try visitor.visitSingularStringField(value: self.implementation, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_InitPluginRequest, rhs: Io_Pact_Plugin_InitPluginRequest) -> Bool {
    if lhs.implementation != rhs.implementation {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_CatalogueEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CatalogueEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "key"),
    3: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .contentMatcher {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    if !self.values.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.values, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_CatalogueEntry, rhs: Io_Pact_Plugin_CatalogueEntry) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.key != rhs.key {return false}
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_CatalogueEntry.EntryType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONTENT_MATCHER"),
    1: .same(proto: "CONTENT_GENERATOR"),
    2: .same(proto: "TRANSPORT"),
    3: .same(proto: "MATCHER"),
    4: .same(proto: "INTERACTION"),
  ]
}

extension Io_Pact_Plugin_InitPluginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitPluginResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "catalogue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.catalogue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.catalogue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.catalogue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_InitPluginResponse, rhs: Io_Pact_Plugin_InitPluginResponse) -> Bool {
    if lhs.catalogue != rhs.catalogue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_Catalogue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Catalogue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "catalogue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.catalogue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.catalogue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.catalogue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_Catalogue, rhs: Io_Pact_Plugin_Catalogue) -> Bool {
    if lhs.catalogue != rhs.catalogue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_Body: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Body"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contentType"),
    2: .same(proto: "content"),
    3: .same(proto: "contentTypeHint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contentType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.contentTypeHint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contentType.isEmpty {
      try visitor.visitSingularStringField(value: self.contentType, fieldNumber: 1)
    }
    try { if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.contentTypeHint != .default {
      try visitor.visitSingularEnumField(value: self.contentTypeHint, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_Body, rhs: Io_Pact_Plugin_Body) -> Bool {
    if lhs.contentType != rhs.contentType {return false}
    if lhs._content != rhs._content {return false}
    if lhs.contentTypeHint != rhs.contentTypeHint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_Body.ContentTypeHint: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "TEXT"),
    2: .same(proto: "BINARY"),
  ]
}

extension Io_Pact_Plugin_CompareContentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompareContentsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expected"),
    2: .same(proto: "actual"),
    3: .standard(proto: "allow_unexpected_keys"),
    4: .same(proto: "rules"),
    5: .same(proto: "pluginConfiguration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._expected) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._actual) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.allowUnexpectedKeys) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Io_Pact_Plugin_MatchingRules>.self, value: &self.rules) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._pluginConfiguration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._expected {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._actual {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.allowUnexpectedKeys != false {
      try visitor.visitSingularBoolField(value: self.allowUnexpectedKeys, fieldNumber: 3)
    }
    if !self.rules.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Io_Pact_Plugin_MatchingRules>.self, value: self.rules, fieldNumber: 4)
    }
    try { if let v = self._pluginConfiguration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_CompareContentsRequest, rhs: Io_Pact_Plugin_CompareContentsRequest) -> Bool {
    if lhs._expected != rhs._expected {return false}
    if lhs._actual != rhs._actual {return false}
    if lhs.allowUnexpectedKeys != rhs.allowUnexpectedKeys {return false}
    if lhs.rules != rhs.rules {return false}
    if lhs._pluginConfiguration != rhs._pluginConfiguration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_ContentTypeMismatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContentTypeMismatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expected"),
    2: .same(proto: "actual"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.expected) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.actual) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.expected.isEmpty {
      try visitor.visitSingularStringField(value: self.expected, fieldNumber: 1)
    }
    if !self.actual.isEmpty {
      try visitor.visitSingularStringField(value: self.actual, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_ContentTypeMismatch, rhs: Io_Pact_Plugin_ContentTypeMismatch) -> Bool {
    if lhs.expected != rhs.expected {return false}
    if lhs.actual != rhs.actual {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_ContentMismatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContentMismatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expected"),
    2: .same(proto: "actual"),
    3: .same(proto: "mismatch"),
    4: .same(proto: "path"),
    5: .same(proto: "diff"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._expected) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._actual) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mismatch) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.diff) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._expected {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._actual {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.mismatch.isEmpty {
      try visitor.visitSingularStringField(value: self.mismatch, fieldNumber: 3)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 4)
    }
    if !self.diff.isEmpty {
      try visitor.visitSingularStringField(value: self.diff, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_ContentMismatch, rhs: Io_Pact_Plugin_ContentMismatch) -> Bool {
    if lhs._expected != rhs._expected {return false}
    if lhs._actual != rhs._actual {return false}
    if lhs.mismatch != rhs.mismatch {return false}
    if lhs.path != rhs.path {return false}
    if lhs.diff != rhs.diff {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_ContentMismatches: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContentMismatches"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mismatches"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.mismatches) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mismatches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mismatches, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_ContentMismatches, rhs: Io_Pact_Plugin_ContentMismatches) -> Bool {
    if lhs.mismatches != rhs.mismatches {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_CompareContentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompareContentsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "typeMismatch"),
    3: .same(proto: "results"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._typeMismatch) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Io_Pact_Plugin_ContentMismatches>.self, value: &self.results) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 1)
    }
    try { if let v = self._typeMismatch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.results.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Io_Pact_Plugin_ContentMismatches>.self, value: self.results, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_CompareContentsResponse, rhs: Io_Pact_Plugin_CompareContentsResponse) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs._typeMismatch != rhs._typeMismatch {return false}
    if lhs.results != rhs.results {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_ConfigureInteractionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfigureInteractionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contentType"),
    2: .same(proto: "contentsConfig"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contentType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._contentsConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contentType.isEmpty {
      try visitor.visitSingularStringField(value: self.contentType, fieldNumber: 1)
    }
    try { if let v = self._contentsConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_ConfigureInteractionRequest, rhs: Io_Pact_Plugin_ConfigureInteractionRequest) -> Bool {
    if lhs.contentType != rhs.contentType {return false}
    if lhs._contentsConfig != rhs._contentsConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_MatchingRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchingRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._values {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_MatchingRule, rhs: Io_Pact_Plugin_MatchingRule) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._values != rhs._values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_MatchingRules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchingRules"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rule"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rule) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rule.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rule, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_MatchingRules, rhs: Io_Pact_Plugin_MatchingRules) -> Bool {
    if lhs.rule != rhs.rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_Generator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Generator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._values {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_Generator, rhs: Io_Pact_Plugin_Generator) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._values != rhs._values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_PluginConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PluginConfiguration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "interactionConfiguration"),
    2: .same(proto: "pactConfiguration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._interactionConfiguration) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pactConfiguration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._interactionConfiguration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pactConfiguration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_PluginConfiguration, rhs: Io_Pact_Plugin_PluginConfiguration) -> Bool {
    if lhs._interactionConfiguration != rhs._interactionConfiguration {return false}
    if lhs._pactConfiguration != rhs._pactConfiguration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_InteractionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InteractionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contents"),
    2: .same(proto: "rules"),
    3: .same(proto: "generators"),
    4: .same(proto: "messageMetadata"),
    5: .same(proto: "pluginConfiguration"),
    6: .same(proto: "interactionMarkup"),
    7: .same(proto: "interactionMarkupType"),
    8: .same(proto: "partName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._contents) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Io_Pact_Plugin_MatchingRules>.self, value: &self.rules) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Io_Pact_Plugin_Generator>.self, value: &self.generators) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._messageMetadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._pluginConfiguration) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.interactionMarkup) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.interactionMarkupType) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.partName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contents {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.rules.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Io_Pact_Plugin_MatchingRules>.self, value: self.rules, fieldNumber: 2)
    }
    if !self.generators.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Io_Pact_Plugin_Generator>.self, value: self.generators, fieldNumber: 3)
    }
    try { if let v = self._messageMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._pluginConfiguration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.interactionMarkup.isEmpty {
      try visitor.visitSingularStringField(value: self.interactionMarkup, fieldNumber: 6)
    }
    if self.interactionMarkupType != .commonMark {
      try visitor.visitSingularEnumField(value: self.interactionMarkupType, fieldNumber: 7)
    }
    if !self.partName.isEmpty {
      try visitor.visitSingularStringField(value: self.partName, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_InteractionResponse, rhs: Io_Pact_Plugin_InteractionResponse) -> Bool {
    if lhs._contents != rhs._contents {return false}
    if lhs.rules != rhs.rules {return false}
    if lhs.generators != rhs.generators {return false}
    if lhs._messageMetadata != rhs._messageMetadata {return false}
    if lhs._pluginConfiguration != rhs._pluginConfiguration {return false}
    if lhs.interactionMarkup != rhs.interactionMarkup {return false}
    if lhs.interactionMarkupType != rhs.interactionMarkupType {return false}
    if lhs.partName != rhs.partName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_InteractionResponse.MarkupType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMMON_MARK"),
    1: .same(proto: "HTML"),
  ]
}

extension Io_Pact_Plugin_ConfigureInteractionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfigureInteractionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "interaction"),
    3: .same(proto: "pluginConfiguration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.interaction) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pluginConfiguration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 1)
    }
    if !self.interaction.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.interaction, fieldNumber: 2)
    }
    try { if let v = self._pluginConfiguration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_ConfigureInteractionResponse, rhs: Io_Pact_Plugin_ConfigureInteractionResponse) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.interaction != rhs.interaction {return false}
    if lhs._pluginConfiguration != rhs._pluginConfiguration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_GenerateContentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateContentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contents"),
    2: .same(proto: "generators"),
    3: .same(proto: "pluginConfiguration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._contents) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Io_Pact_Plugin_Generator>.self, value: &self.generators) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pluginConfiguration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contents {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.generators.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Io_Pact_Plugin_Generator>.self, value: self.generators, fieldNumber: 2)
    }
    try { if let v = self._pluginConfiguration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_GenerateContentRequest, rhs: Io_Pact_Plugin_GenerateContentRequest) -> Bool {
    if lhs._contents != rhs._contents {return false}
    if lhs.generators != rhs.generators {return false}
    if lhs._pluginConfiguration != rhs._pluginConfiguration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_GenerateContentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateContentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contents"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._contents) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contents {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_GenerateContentResponse, rhs: Io_Pact_Plugin_GenerateContentResponse) -> Bool {
    if lhs._contents != rhs._contents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_StartMockServerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartMockServerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hostInterface"),
    2: .same(proto: "port"),
    3: .same(proto: "tls"),
    4: .same(proto: "pact"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hostInterface) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.tls) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pact) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hostInterface.isEmpty {
      try visitor.visitSingularStringField(value: self.hostInterface, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 2)
    }
    if self.tls != false {
      try visitor.visitSingularBoolField(value: self.tls, fieldNumber: 3)
    }
    if !self.pact.isEmpty {
      try visitor.visitSingularStringField(value: self.pact, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_StartMockServerRequest, rhs: Io_Pact_Plugin_StartMockServerRequest) -> Bool {
    if lhs.hostInterface != rhs.hostInterface {return false}
    if lhs.port != rhs.port {return false}
    if lhs.tls != rhs.tls {return false}
    if lhs.pact != rhs.pact {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_StartMockServerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartMockServerResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      case 2: try {
        var v: Io_Pact_Plugin_MockServerDetails?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .details(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .details(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .details?: try {
      guard case .details(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_StartMockServerResponse, rhs: Io_Pact_Plugin_StartMockServerResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_MockServerDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MockServerDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "port"),
    3: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 2)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_MockServerDetails, rhs: Io_Pact_Plugin_MockServerDetails) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.port != rhs.port {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_ShutdownMockServerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShutdownMockServerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serverKey"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serverKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverKey.isEmpty {
      try visitor.visitSingularStringField(value: self.serverKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_ShutdownMockServerRequest, rhs: Io_Pact_Plugin_ShutdownMockServerRequest) -> Bool {
    if lhs.serverKey != rhs.serverKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_MockServerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MockServerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serverKey"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serverKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverKey.isEmpty {
      try visitor.visitSingularStringField(value: self.serverKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_MockServerRequest, rhs: Io_Pact_Plugin_MockServerRequest) -> Bool {
    if lhs.serverKey != rhs.serverKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_MockServerResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MockServerResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "error"),
    3: .same(proto: "mismatches"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mismatches) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    if !self.mismatches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mismatches, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_MockServerResult, rhs: Io_Pact_Plugin_MockServerResult) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.error != rhs.error {return false}
    if lhs.mismatches != rhs.mismatches {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_ShutdownMockServerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShutdownMockServerResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ok"),
    2: .same(proto: "results"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.ok) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ok != false {
      try visitor.visitSingularBoolField(value: self.ok, fieldNumber: 1)
    }
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_ShutdownMockServerResponse, rhs: Io_Pact_Plugin_ShutdownMockServerResponse) -> Bool {
    if lhs.ok != rhs.ok {return false}
    if lhs.results != rhs.results {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_MockServerResults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MockServerResults"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ok"),
    2: .same(proto: "results"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.ok) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ok != false {
      try visitor.visitSingularBoolField(value: self.ok, fieldNumber: 1)
    }
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_MockServerResults, rhs: Io_Pact_Plugin_MockServerResults) -> Bool {
    if lhs.ok != rhs.ok {return false}
    if lhs.results != rhs.results {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_VerificationPreparationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerificationPreparationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pact"),
    2: .same(proto: "interactionKey"),
    3: .same(proto: "config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pact) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.interactionKey) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pact.isEmpty {
      try visitor.visitSingularStringField(value: self.pact, fieldNumber: 1)
    }
    if !self.interactionKey.isEmpty {
      try visitor.visitSingularStringField(value: self.interactionKey, fieldNumber: 2)
    }
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_VerificationPreparationRequest, rhs: Io_Pact_Plugin_VerificationPreparationRequest) -> Bool {
    if lhs.pact != rhs.pact {return false}
    if lhs.interactionKey != rhs.interactionKey {return false}
    if lhs._config != rhs._config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_MetadataValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetadataValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonBinaryValue"),
    2: .same(proto: "binaryValue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SwiftProtobuf.Google_Protobuf_Value?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .nonBinaryValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .nonBinaryValue(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .binaryValue(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .nonBinaryValue?: try {
      guard case .nonBinaryValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .binaryValue?: try {
      guard case .binaryValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_MetadataValue, rhs: Io_Pact_Plugin_MetadataValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_InteractionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InteractionData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Io_Pact_Plugin_MetadataValue>.self, value: &self.metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Io_Pact_Plugin_MetadataValue>.self, value: self.metadata, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_InteractionData, rhs: Io_Pact_Plugin_InteractionData) -> Bool {
    if lhs._body != rhs._body {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_VerificationPreparationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerificationPreparationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "interactionData"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      case 2: try {
        var v: Io_Pact_Plugin_InteractionData?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .interactionData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .interactionData(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .interactionData?: try {
      guard case .interactionData(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_VerificationPreparationResponse, rhs: Io_Pact_Plugin_VerificationPreparationResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_VerifyInteractionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerifyInteractionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "interactionData"),
    2: .same(proto: "config"),
    3: .same(proto: "pact"),
    4: .same(proto: "interactionKey"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._interactionData) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pact) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.interactionKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._interactionData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.pact.isEmpty {
      try visitor.visitSingularStringField(value: self.pact, fieldNumber: 3)
    }
    if !self.interactionKey.isEmpty {
      try visitor.visitSingularStringField(value: self.interactionKey, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_VerifyInteractionRequest, rhs: Io_Pact_Plugin_VerifyInteractionRequest) -> Bool {
    if lhs._interactionData != rhs._interactionData {return false}
    if lhs._config != rhs._config {return false}
    if lhs.pact != rhs.pact {return false}
    if lhs.interactionKey != rhs.interactionKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_VerificationResultItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerificationResultItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "mismatch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      case 2: try {
        var v: Io_Pact_Plugin_ContentMismatch?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .mismatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .mismatch(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .mismatch?: try {
      guard case .mismatch(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_VerificationResultItem, rhs: Io_Pact_Plugin_VerificationResultItem) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_VerificationResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerificationResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "responseData"),
    3: .same(proto: "mismatches"),
    4: .same(proto: "output"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._responseData) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mismatches) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.output) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._responseData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.mismatches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mismatches, fieldNumber: 3)
    }
    if !self.output.isEmpty {
      try visitor.visitRepeatedStringField(value: self.output, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_VerificationResult, rhs: Io_Pact_Plugin_VerificationResult) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._responseData != rhs._responseData {return false}
    if lhs.mismatches != rhs.mismatches {return false}
    if lhs.output != rhs.output {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Pact_Plugin_VerifyInteractionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerifyInteractionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      case 2: try {
        var v: Io_Pact_Plugin_VerificationResult?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .result(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .result(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .result?: try {
      guard case .result(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Io_Pact_Plugin_VerifyInteractionResponse, rhs: Io_Pact_Plugin_VerifyInteractionResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
